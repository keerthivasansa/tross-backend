// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: query.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createGoal = `-- name: CreateGoal :execresult
INSERT INTO goals (user_id, name, content, active) VALUES (?, ?, ?, ?)
`

type CreateGoalParams struct {
	UserID  string `json:"user_id"`
	Name    string `json:"name"`
	Content string `json:"content"`
	Active  bool   `json:"active"`
}

func (q *Queries) CreateGoal(ctx context.Context, arg CreateGoalParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createGoal,
		arg.UserID,
		arg.Name,
		arg.Content,
		arg.Active,
	)
}

const createUser = `-- name: CreateUser :execresult
INSERT INTO users (id, name) VALUES (?, ?)
`

type CreateUserParams struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUser, arg.ID, arg.Name)
}

const fetchFirstGoalDate = `-- name: FetchFirstGoalDate :one
SELECT g.created_at FROM goals g WHERE g.user_id = ? ORDER BY g.created_at ASC LIMIT 1
`

func (q *Queries) FetchFirstGoalDate(ctx context.Context, userID string) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, fetchFirstGoalDate, userID)
	var created_at time.Time
	err := row.Scan(&created_at)
	return created_at, err
}

const getAllGoals = `-- name: GetAllGoals :many
SELECT id, content, name, user_id, created_at, active FROM goals WHERE user_id = ?
`

func (q *Queries) GetAllGoals(ctx context.Context, userID string) ([]Goal, error) {
	rows, err := q.db.QueryContext(ctx, getAllGoals, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Goal
	for rows.Next() {
		var i Goal
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.Name,
			&i.UserID,
			&i.CreatedAt,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT name, id FROM users
`

func (q *Queries) GetAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(&i.Name, &i.ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBioForAuthor = `-- name: GetBioForAuthor :one
SELECT name, id FROM users WHERE id = ?
`

func (q *Queries) GetBioForAuthor(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getBioForAuthor, id)
	var i User
	err := row.Scan(&i.Name, &i.ID)
	return i, err
}

const getDays = `-- name: GetDays :many
SELECT day FROM relapsed_days WHERE goal_id = ?
`

func (q *Queries) GetDays(ctx context.Context, goalID int32) ([]time.Time, error) {
	rows, err := q.db.QueryContext(ctx, getDays, goalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var day time.Time
		if err := rows.Scan(&day); err != nil {
			return nil, err
		}
		items = append(items, day)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGoalsWithName = `-- name: GetGoalsWithName :many
SELECT u.name as UserName, g.name as GoalName, g.active FROM goals g, users u WHERE g.user_id = u.id AND u.name LIKE ?
`

type GetGoalsWithNameRow struct {
	Username string `json:"username"`
	Goalname string `json:"goalname"`
	Active   bool   `json:"active"`
}

func (q *Queries) GetGoalsWithName(ctx context.Context, name string) ([]GetGoalsWithNameRow, error) {
	rows, err := q.db.QueryContext(ctx, getGoalsWithName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGoalsWithNameRow
	for rows.Next() {
		var i GetGoalsWithNameRow
		if err := rows.Scan(&i.Username, &i.Goalname, &i.Active); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProgress = `-- name: GetProgress :one
SELECT g.id, g.created_at, COUNT(r.day) fROM relapsed_days r, goals g WHERE g.id = r.goal_id AND g.id = ? GROUP BY g.id, g.created_at
`

type GetProgressRow struct {
	ID        int32     `json:"id"`
	CreatedAt time.Time `json:"created_at"`
	Count     int64     `json:"count"`
}

func (q *Queries) GetProgress(ctx context.Context, id int32) (GetProgressRow, error) {
	row := q.db.QueryRowContext(ctx, getProgress, id)
	var i GetProgressRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.Count)
	return i, err
}

const markRelapse = `-- name: MarkRelapse :exec
INSERT INTO relapsed_days (day, goal_id) VALUES (?, ?)
`

type MarkRelapseParams struct {
	Day    time.Time `json:"day"`
	GoalID int32     `json:"goal_id"`
}

func (q *Queries) MarkRelapse(ctx context.Context, arg MarkRelapseParams) error {
	_, err := q.db.ExecContext(ctx, markRelapse, arg.Day, arg.GoalID)
	return err
}
